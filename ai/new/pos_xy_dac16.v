// -------------------------------------------------------------
//
// File Name: hdlsrc\pos_xy_dac16.v
// Created: 2015-03-13 09:03:54
// Generated by MATLAB 7.6 and Simulink HDL Coder 1.3
//
//
// -------------------------------------------------------------


// -------------------------------------------------------------
//
// Module: pos_xy_dac16
// Source Path: fofb_pos_nm2dac16bit/pos_xy_dac16
// Hierarchy Level: 1
//
//
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module pos_xy_dac16
          (
           clk,
           reset,
           enb,
           pos_nm,
           scale,
           OutU20b
          );


  input   clk;
  input   reset;
  input   enb;
  input   signed [31:0] pos_nm;  // int32
  input   signed [31:0] scale;  // sfix32_En31
  output  [15:0] OutU20b;  // uint16


  reg signed [31:0] Delay1_out1;  // int32
  wire signed [31:0] Product1_out1;  // int32
  wire signed [15:0] ToFix20bit_out1;  // int16
  wire signed [15:0] OFFSET_out1;  // int16
  wire [15:0] Sum2_out1;  // uint16
  wire [15:0] IREF_MAX_MIN_out1;  // uint16
  reg [15:0] Delay3_out1;  // uint16
  wire signed [63:0] mul_temp;  // sfix64_En31
  wire signed [16:0] Sum2_out1_tmp;  // sfix17
  wire signed [16:0] add_cast;  // sfix17
  wire signed [16:0] add_cast_1;  // sfix17
  wire signed [17:0] add_temp;  // sfix18
  wire [15:0] IREF_MAX_MIN_upper_limit_out;  // uint16
  wire [15:0] IREF_MAX_MIN_lower_limit_out;  // uint16

  always @ (posedge clk or posedge reset)
    begin: Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay1_out1 <= pos_nm;
        end
      end
    end // Delay1_process

  assign mul_temp = Delay1_out1 * scale;
  assign Product1_out1 = (mul_temp[62:30] + 1)>>>1;

  assign ToFix20bit_out1 = ((Product1_out1[31] == 1'b0 & Product1_out1[30:15] != 16'b0000000000000000) || (Product1_out1[31] == 1'b0 && Product1_out1[15:0] == 16'b0111111111111111) // special case0
) ? 16'b0111111111111111 : 
      (Product1_out1[31] == 1'b1 && Product1_out1[30:15] != 16'b1111111111111111) ? 16'b1000000000000000 : Product1_out1[15:0];

  assign OFFSET_out1 = 16'b0111111111111111;

  assign add_cast = $signed({{1{ToFix20bit_out1[15]}}, ToFix20bit_out1});
  assign add_cast_1 = $signed({{1{OFFSET_out1[15]}}, OFFSET_out1});
  assign add_temp = add_cast + add_cast_1;
  assign Sum2_out1_tmp = (add_temp[17] == 1'b0 & add_temp[16] != 1'b0) ? 17'b01111111111111111 : 
      (add_temp[17] == 1'b1 && add_temp[16] != 1'b1) ? 17'b10000000000000000 : add_temp[16:0];

  assign Sum2_out1 = (Sum2_out1_tmp[16] == 1'b1 ) ? 16'b0000000000000000 : $unsigned(Sum2_out1_tmp[15:0]);


// Saturation block implementation

// Upper Limit (output data type)
  assign IREF_MAX_MIN_upper_limit_out = 16'b1111111111111111;

// Lower Limit (output data type)
  assign IREF_MAX_MIN_lower_limit_out = 16'b0000000000000000;

// Mux for Saturation logic:
// if input is > upper limit, assign upper limit to output
// else if input is < lower limit, assign lower limit to output
// else assign input to output
// if upper limit is equal to lower limit, assign upper limit to output
// 
// Ignoring comparison to the Lower Limit since the input can never be 
// less than the Lower Limit
// Ignoring comparison to the Upper Limit since the input can never be 
// greater than the Upper Limit
// No comparison needed to the Upper/Lower Limits => assign input to output
  assign IREF_MAX_MIN_out1 = Sum2_out1;

  always @ (posedge clk or posedge reset)
    begin: Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay3_out1 <= IREF_MAX_MIN_out1;
        end
      end
    end // Delay3_process

  assign OutU20b = Delay3_out1;

endmodule  // pos_xy_dac16

