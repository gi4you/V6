// -------------------------------------------------------------
//
// File Name: fpga\nco_cos20b.v
// Created: 2012-11-29 22:27:40
// Generated by MATLAB 7.6 and Simulink HDL Coder 1.3
//
// 
//
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module nco_cos20b
          (
           clk,
           reset,
           clk_enable,
           Kx,
           Ky,
           Kxoff,
           Kyoff,
           freq,
           ce_out,
           cos_x,
           cos_y
          );


  input   clk;
  input   reset;
  input   clk_enable;
  input   [19:0] Kx;  // ufix20
  input   [19:0] Ky;  // ufix20
  input   signed [19:0] Kxoff;  // sfix20
  input   [19:0] Kyoff;  // ufix20
  input   signed [31:0] freq;  // int32
  output  ce_out;
  output  signed [19:0] cos_x;  // sfix20
  output  signed [19:0] cos_y;  // sfix20

  parameter [6:0] C_NCO_ADDR_MAX = 7'b1000000;  // ufix7_E24
  parameter signed [19:0] C_NCO_EXTRA_QTR_WAVE_VAL = 20'b01111111111111111111;  // sfix20_En19
  parameter [7:0] C_NCO_90DEG = 8'b01000000;  // ufix8_E24

  wire enb;
  wire enb_1_1_1;
  reg signed [31:0] Delay1_out1;  // int32
  wire signed [31:0] In2_out1;  // int32
  wire signed [19:0] NCO1_out1;  // sfix20_En19
  reg signed [19:0] Delay2_out1;  // sfix20_En19
  wire signed [19:0] Divide1_out1;  // sfix20
  wire signed [19:0] Add1_out1;  // sfix20
  wire signed [19:0] Divide2_out1;  // sfix20
  wire signed [19:0] Add2_out1;  // sfix20
  wire signed [31:0] phase_increment;  // int32
  reg signed [31:0] accumulator_reg;  // int32
  wire signed [31:0] accumulator_input;  // int32
  wire signed [31:0] add_signext;  // int32
  wire signed [31:0] add_signext_1;  // int32
  wire signed [32:0] add_temp;  // sfix33
  wire signed [31:0] phase_offset;  // int32
  wire signed [31:0] total_phase;  // int32
  wire signed [31:0] add_signext_2;  // int32
  wire signed [31:0] add_signext_3;  // int32
  wire signed [32:0] add_temp_1;  // sfix33
  wire signed [31:0] dithered_phase;  // int32
  reg [11:0] pn_reg;  // ufix12
  wire pn_out;
  wire pn_xorout;
  wire [11:0] pn_newvalue [0:1];  // ufix12 [2]
  wire [10:0] pn_value_shifted;  // ufix11_E1
  wire [7:0] quantized_phase;  // ufix8_E24
  wire [5:0] lutaddr_quadrant1;  // ufix6_E24
  wire [5:0] lutaddr_quadrant2;  // ufix6_E24
  wire [6:0] sub_signext;  // ufix7_E24
  wire [6:0] sub_signext_1;  // ufix7_E24
  wire [7:0] sub_temp;  // ufix8_E24
  wire [6:0] cos_extra_value_cmp_in;  // ufix7_E24
  wire cos_inv_hwoutput;
  wire cos_addr_mux_sel;
  wire [1:0] quantized_phase_2msbs;  // ufix2_E30
  wire [1:0] cos_control_bits;  // ufix2_E30
  wire [7:0] add_signext_4;  // ufix8_E24
  wire [7:0] add_signext_5;  // ufix8_E24
  wire [8:0] add_temp_2;  // ufix9_E24
  wire [5:0] coslutaddr;  // ufix6_E24
  wire signed [19:0] coslut_output;  // sfix20_En19
  wire signed [19:0] cos_hw;  // sfix20_En19
  reg [18:0] coslut_output_unsigned;  // ufix19_En19
  wire signed [19:0] cos_hw_inv;  // sfix20_En19
  wire signed [20:0] unaryminus_temp;  // sfix21_En19
  wire signed [40:0] mul_temp;  // sfix41_En19
  wire signed [20:0] Add1_out1_tmp;  // sfix21
  wire signed [20:0] add_cast;  // sfix21
  wire signed [20:0] add_cast_1;  // sfix21
  wire signed [21:0] add_temp_3;  // sfix22
  wire signed [40:0] mul_temp_1;  // sfix41_En19
  wire signed [21:0] Add2_out1_tmp;  // sfix22
  wire signed [21:0] add_cast_2;  // sfix22
  wire signed [21:0] add_cast_3;  // sfix22
  wire signed [22:0] add_temp_4;  // sfix23

  assign enb_1_1_1 = clk_enable;
  assign ce_out = enb_1_1_1;
  always @ (posedge clk)
    begin: Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay1_out1 <= freq;
        end
      end
    end // Delay1_process

  assign In2_out1 = 32'h00000000;


// *** NCO ***

  assign phase_increment = Delay1_out1;

// ********************************
// PHASE ACCUMULATION
// ********************************

  assign add_signext = accumulator_reg;
  assign add_signext_1 = phase_increment;
  assign add_temp = add_signext + add_signext_1;
  assign accumulator_input = add_temp[31:0];

  always @ ( posedge clk)
    begin: NCO1_phase_accumulator_temp_process1
      if (reset == 1'b1) begin
        accumulator_reg <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          accumulator_reg <= accumulator_input;
        end
      end
    end // NCO1_phase_accumulator_temp_process1

  assign phase_offset = In2_out1;

// ********************************
// PHASE OFFSET ADDITION
// ********************************

  assign add_signext_2 = accumulator_reg;
  assign add_signext_3 = phase_offset;
  assign add_temp_1 = add_signext_2 + add_signext_3;
  assign total_phase = add_temp_1[31:0];

// ********************************
// DITHER
// ********************************

  assign pn_newvalue[0] = pn_reg;

  assign pn_xorout = pn_newvalue[0][0] ^ pn_newvalue[0][6] ^ pn_newvalue[0][8] ^ pn_newvalue[0][11];

  assign pn_value_shifted = pn_newvalue[0][11:1];

  assign pn_newvalue[1] = {pn_xorout, pn_value_shifted};

  assign pn_out = pn_newvalue[0][0];

  always @ ( posedge clk)
    begin: PN_generation_temp_process2
      if (reset == 1'b1) begin
        pn_reg <= 12'b000000000001;
      end
      else begin
        if (enb == 1'b1) begin
          pn_reg <= pn_newvalue[1];
        end
      end
    end // PN_generation_temp_process2

  assign dithered_phase = (pn_out == 1)? $signed({{1{total_phase[31]}}, total_phase}) + 1 : $signed({{1{total_phase[31]}}, total_phase});

// ********************************
// PHASE QUANTIZATION
// ********************************

  assign quantized_phase = $unsigned(dithered_phase[31:24]);

// ********************************
// QUARTER WAVE LOOKUP TABLE
// The sinusoid is implemented via a quarter wave lookup table.
// The values of the first quadrant of a SINE function are stored in the lookup table.
// The lower 6 quantized phase bits form the address to the lookup table.
// There are 2^6 values in the table on the interval [0,pi/2).
// One extra value, sin(pi/2), is muxed into the output of the table.
// The most significant two quantized phase bits determine how the quarter wave should be
// reflect and/or inverted to create a full sinusoid.
// ********************************



// generation of LUT address and control signals

  assign lutaddr_quadrant1 = quantized_phase[5:0];

  assign sub_signext = C_NCO_ADDR_MAX;
  assign sub_signext_1 = {1'b0, lutaddr_quadrant1};
  assign sub_temp = sub_signext - sub_signext_1;
  assign lutaddr_quadrant2 = sub_temp[5:0];

  assign quantized_phase_2msbs = quantized_phase[7:6];

  assign add_signext_4 = quantized_phase;
  assign add_signext_5 = C_NCO_90DEG;
  assign add_temp_2 = add_signext_4 + add_signext_5;
  assign cos_control_bits = add_temp_2[7:6];

  assign cos_inv_hwoutput = {cos_control_bits[1]};

  assign cos_addr_mux_sel = {cos_control_bits[0]};

  assign cos_extra_value_cmp_in = {cos_control_bits[0], lutaddr_quadrant1};

  assign coslutaddr = (cos_addr_mux_sel == 1'b0) ? lutaddr_quadrant1 :
                lutaddr_quadrant2;


// quarter wave LUT

  always @(coslutaddr)
  begin
    case(coslutaddr)
      6'b000000 : coslut_output_unsigned = 19'b0000000000000000000;
      6'b000001 : coslut_output_unsigned = 19'b0000011001001000011;
      6'b000010 : coslut_output_unsigned = 19'b0000110010001111110;
      6'b000011 : coslut_output_unsigned = 19'b0001001011010101001;
      6'b000100 : coslut_output_unsigned = 19'b0001100100010111101;
      6'b000101 : coslut_output_unsigned = 19'b0001111101010110010;
      6'b000110 : coslut_output_unsigned = 19'b0010010110010000001;
      6'b000111 : coslut_output_unsigned = 19'b0010101111000100001;
      6'b001000 : coslut_output_unsigned = 19'b0011000111110001100;
      6'b001001 : coslut_output_unsigned = 19'b0011100000010111000;
      6'b001010 : coslut_output_unsigned = 19'b0011111000110100000;
      6'b001011 : coslut_output_unsigned = 19'b0100010001000111010;
      6'b001100 : coslut_output_unsigned = 19'b0100101001010000001;
      6'b001101 : coslut_output_unsigned = 19'b0101000001001101100;
      6'b001110 : coslut_output_unsigned = 19'b0101011000111110011;
      6'b001111 : coslut_output_unsigned = 19'b0101110000100010001;
      6'b010000 : coslut_output_unsigned = 19'b0110000111110111100;
      6'b010001 : coslut_output_unsigned = 19'b0110011110111101111;
      6'b010010 : coslut_output_unsigned = 19'b0110110101110100010;
      6'b010011 : coslut_output_unsigned = 19'b0111001100011001110;
      6'b010100 : coslut_output_unsigned = 19'b0111100010101101100;
      6'b010101 : coslut_output_unsigned = 19'b0111111000101110101;
      6'b010110 : coslut_output_unsigned = 19'b1000001110011100010;
      6'b010111 : coslut_output_unsigned = 19'b1000100011110101101;
      6'b011000 : coslut_output_unsigned = 19'b1000111000111001111;
      6'b011001 : coslut_output_unsigned = 19'b1001001101101000001;
      6'b011010 : coslut_output_unsigned = 19'b1001100001111111110;
      6'b011011 : coslut_output_unsigned = 19'b1001110101111111111;
      6'b011100 : coslut_output_unsigned = 19'b1010001001100111101;
      6'b011101 : coslut_output_unsigned = 19'b1010011100110110011;
      6'b011110 : coslut_output_unsigned = 19'b1010101111101011010;
      6'b011111 : coslut_output_unsigned = 19'b1011000010000101110;
      6'b100000 : coslut_output_unsigned = 19'b1011010100000101000;
      6'b100001 : coslut_output_unsigned = 19'b1011100101101000010;
      6'b100010 : coslut_output_unsigned = 19'b1011110110101111000;
      6'b100011 : coslut_output_unsigned = 19'b1100000111011000100;
      6'b100100 : coslut_output_unsigned = 19'b1100010111100100000;
      6'b100101 : coslut_output_unsigned = 19'b1100100111010001001;
      6'b100110 : coslut_output_unsigned = 19'b1100110110011111000;
      6'b100111 : coslut_output_unsigned = 19'b1101000101001101010;
      6'b101000 : coslut_output_unsigned = 19'b1101010011011011010;
      6'b101001 : coslut_output_unsigned = 19'b1101100001001000011;
      6'b101010 : coslut_output_unsigned = 19'b1101101110010100001;
      6'b101011 : coslut_output_unsigned = 19'b1101111010111110000;
      6'b101100 : coslut_output_unsigned = 19'b1110000111000101101;
      6'b101101 : coslut_output_unsigned = 19'b1110010010101010011;
      6'b101110 : coslut_output_unsigned = 19'b1110011101101011111;
      6'b101111 : coslut_output_unsigned = 19'b1110101000001001101;
      6'b110000 : coslut_output_unsigned = 19'b1110110010000011011;
      6'b110001 : coslut_output_unsigned = 19'b1110111011011000101;
      6'b110010 : coslut_output_unsigned = 19'b1111000100001001000;
      6'b110011 : coslut_output_unsigned = 19'b1111001100010100010;
      6'b110100 : coslut_output_unsigned = 19'b1111010011111010000;
      6'b110101 : coslut_output_unsigned = 19'b1111011010111010000;
      6'b110110 : coslut_output_unsigned = 19'b1111100001010100000;
      6'b110111 : coslut_output_unsigned = 19'b1111100111000111101;
      6'b111000 : coslut_output_unsigned = 19'b1111101100010100110;
      6'b111001 : coslut_output_unsigned = 19'b1111110000111011001;
      6'b111010 : coslut_output_unsigned = 19'b1111110100111010101;
      6'b111011 : coslut_output_unsigned = 19'b1111111000010011001;
      6'b111100 : coslut_output_unsigned = 19'b1111111011000100011;
      6'b111101 : coslut_output_unsigned = 19'b1111111101001110011;
      6'b111110 : coslut_output_unsigned = 19'b1111111110110001000;
      6'b111111 : coslut_output_unsigned = 19'b1111111111101100010;
      default : coslut_output_unsigned = 19'b1111111111101100010;
    endcase
  end

  assign coslut_output = $signed({1'b0, coslut_output_unsigned});


// mux in sin(pi/2) for efficent ROM usage

  assign cos_hw = (cos_extra_value_cmp_in != 7'b1000000) ? coslut_output :
            C_NCO_EXTRA_QTR_WAVE_VAL;


// invert halfwave cos to create a fullwave cos

  assign unaryminus_temp = (cos_hw==20'b10000000000000000000) ? $signed({1'b0, cos_hw}) : -cos_hw;
  assign cos_hw_inv = unaryminus_temp[19:0];

  assign NCO1_out1 = (cos_inv_hwoutput == 1'b0) ? cos_hw :
               cos_hw_inv;

  always @ (posedge clk)
    begin: Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay2_out1 <= NCO1_out1;
        end
      end
    end // Delay2_process

  assign mul_temp = Delay2_out1 * $signed({1'b0, Kx});
  assign Divide1_out1 = mul_temp[38:19];

  assign add_cast = $signed({{1{Divide1_out1[19]}}, Divide1_out1});
  assign add_cast_1 = $signed({{1{Kxoff[19]}}, Kxoff});
  assign add_temp_3 = add_cast + add_cast_1;
  assign Add1_out1_tmp = add_temp_3[20:0];

  assign Add1_out1 = Add1_out1_tmp[19:0];

  assign cos_x = Add1_out1;
  assign mul_temp_1 = NCO1_out1 * $signed({1'b0, Ky});
  assign Divide2_out1 = mul_temp_1[38:19];

  assign add_cast_2 = $signed({{2{Divide2_out1[19]}}, Divide2_out1});
  assign add_cast_3 = $signed({2'b00, Kyoff});
  assign add_temp_4 = add_cast_2 + add_cast_3;
  assign Add2_out1_tmp = add_temp_4[21:0];

  assign Add2_out1 = Add2_out1_tmp[19:0];

  assign cos_y = Add2_out1;
  assign enb = clk_enable;

endmodule  // nco_cos20b

