// -------------------------------------------------------------
//
// File Name: hdlsrc\fa_um_lp_filt.v
// Created: 2014-03-28 12:45:25
// Generated by MATLAB 7.6 and Simulink HDL Coder 1.3
//
//
// -------------------------------------------------------------


// -------------------------------------------------------------
//
// Module: fa_um_lp_filt
// Source Path: fa_um_lp_filt
// Hierarchy Level: 0
//
// Simulink model description for fa_um_lp_filt:
  // 8-Point DCT
  // This model shows how to use Simulink(R) HDL Coder(TM) to check, generate,
  // and verify HDL for a fixed-point DCT conversion model. 
// Simulink subsystem description for fa_um_lp_filt:
  // 8-Point DCT
  // This model shows how to use Simulink(R) HDL Coder(TM) to check, generate,
  // and verify HDL for a fixed-point DCT conversion model. 
// 
// Control File:
//   dct8_fixed_control.m
// 
//
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module fa_um_lp_filt
          (
           clk,
           reset,
           clk_enable,
           x_nm_i,
           y_nm_i,
           i_gain,
           trig_in,
           factor,
           ce_out,
           x_um_filt_o,
           x_um_o,
           y_um_filt_o,
           y_um_o,
           x_dt_nm_o,
           y_dt_nm_o,
           trig_out,
           y_dt_nm_10hz_o,
           x_dt_nm_10hz_o,
           x_um_filt_10hz_o,
           y_um_filt_10hz_o
          );


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [31:0] x_nm_i;  // int32
  input   signed [31:0] y_nm_i;  // int32
  input   [31:0] i_gain;  // uint32
  input   trig_in;
  input   signed [15:0] factor;  // int16
  output  ce_out;
  output  signed [31:0] x_um_filt_o;  // int32
  output  signed [31:0] x_um_o;  // int32
  output  signed [31:0] y_um_filt_o;  // int32
  output  signed [31:0] y_um_o;  // int32
  output  signed [31:0] x_dt_nm_o;  // int32
  output  signed [31:0] y_dt_nm_o;  // int32
  output  trig_out;
  output  signed [31:0] y_dt_nm_10hz_o;  // int32
  output  signed [31:0] x_dt_nm_10hz_o;  // int32
  output  signed [31:0] x_um_filt_10hz_o;  // int32
  output  signed [31:0] y_um_filt_10hz_o;  // int32

  parameter signed [31:0] dt_Int_1_InitialCondition = 0;  // int32
  parameter signed [31:0] dt_Int_1_gainval = 439804651;  // int32
  parameter signed [31:0] dt_Int_2_InitialCondition = 0;  // int32
  parameter signed [31:0] dt_Int_2_gainval = 439804651;  // int32

  wire enb;
  wire enb_1_1_1;
  wire signed [31:0] GAIN_MAX_MIN_out1;  // int32
  reg signed [31:0] Delay1_out1;  // int32
  wire signed [31:0] POS_MAX_MIN_out1;  // int32
  wire signed [31:0] mult0_out1;  // int32
  wire signed [31:0] dt_Int_1_out1;  // int32
  wire signed [31:0] Sum13_out1;  // int32
  wire signed [31:0] mult1_out1;  // int32
  reg signed [31:0] Delay7_out1;  // int32
  reg signed [31:0] Delay2_out1;  // int32
  wire signed [31:0] POS_MAX_MIN1_out1;  // int32
  wire signed [31:0] mult2_out1;  // int32
  wire signed [31:0] dt_Int_2_out1;  // int32
  wire signed [31:0] Sum1_out1;  // int32
  wire signed [31:0] mult3_out1;  // int32
  reg signed [31:0] Delay6_out1;  // int32
  reg signed [31:0] Delay3_out1;  // int32
  wire signed [31:0] Sum2_out1;  // int32
  reg signed [31:0] Delay8_out1;  // int32
  reg signed [31:0] Delay5_out1;  // int32
  wire signed [31:0] Sum5_out1;  // int32
  reg signed [31:0] Delay4_out1;  // int32
  wire Logical_Operator_out1;
  reg  Integer_Delay_out1;
  wire Logical_Operator2_out1;
  reg signed [31:0] cell1_out1;  // int32
  reg signed [31:0] cell2_out1;  // int32
  reg signed [31:0] cell3_out1;  // int32
  reg signed [31:0] cell4_out1;  // int32
  wire signed [15:0] um_const_out1;  // sfix16_En15
  reg signed [31:0] dt_Int_1_state0;  // int32
  wire signed [31:0] dt_Int_1_state0_next;  // int32
  wire signed [63:0] t_2;  // sfix64
  wire signed [31:0] t_3;  // int32
  reg signed [31:0] dt_Int_2_state0;  // int32
  wire signed [31:0] dt_Int_2_state0_next;  // int32
  wire signed [63:0] t_2_1;  // sfix64
  wire signed [31:0] t_3_1;  // int32
  wire signed [31:0] GAIN_MAX_MIN_upper_limit_out;  // int32
  wire signed [31:0] GAIN_MAX_MIN_lower_limit_out;  // int32
  wire [31:0] GAIN_MAX_MIN_upper_limit_int;  // uint32
  wire [31:0] GAIN_MAX_MIN_lower_limit_int;  // uint32
  wire signed [31:0] i_gain_out;  // int32
  wire signed [31:0] POS_MAX_MIN_upper_limit_out;  // int32
  wire signed [31:0] POS_MAX_MIN_lower_limit_out;  // int32
  wire signed [47:0] mul_temp;  // sfix48
  wire signed [32:0] Sum13_out1_tmp;  // sfix33
  wire signed [32:0] sub_cast;  // sfix33
  wire signed [32:0] sub_cast_1;  // sfix33
  wire signed [33:0] sub_temp;  // sfix34
  wire signed [63:0] mul_temp_1;  // sfix64
  wire signed [31:0] POS_MAX_MIN1_upper_limit_out;  // int32
  wire signed [31:0] POS_MAX_MIN1_lower_limit_out;  // int32
  wire signed [47:0] mul_temp_2;  // sfix48
  wire signed [32:0] Sum1_out1_tmp;  // sfix33
  wire signed [32:0] sub_cast_2;  // sfix33
  wire signed [32:0] sub_cast_3;  // sfix33
  wire signed [33:0] sub_temp_1;  // sfix34
  wire signed [63:0] mul_temp_3;  // sfix64
  wire signed [32:0] Sum2_out1_tmp;  // sfix33
  wire signed [32:0] sub_cast_4;  // sfix33
  wire signed [32:0] sub_cast_5;  // sfix33
  wire signed [33:0] sub_temp_2;  // sfix34
  wire signed [32:0] Sum5_out1_tmp;  // sfix33
  wire signed [32:0] sub_cast_6;  // sfix33
  wire signed [32:0] sub_cast_7;  // sfix33
  wire signed [33:0] sub_temp_3;  // sfix34

  assign enb_1_1_1 = clk_enable;
  assign ce_out = enb_1_1_1;

// Saturation block implementation

// Upper Limit (output data type)
  assign GAIN_MAX_MIN_upper_limit_out = 32'h0000EA60;

// Lower Limit (output data type)
  assign GAIN_MAX_MIN_lower_limit_out = 32'h000003E8;

// Upper Limit (intermediate data type)
  assign GAIN_MAX_MIN_upper_limit_int = 32'h0000ea60;

// Lower Limit (intermediate data type)
  assign GAIN_MAX_MIN_lower_limit_int = 32'h000003e8;

// Convert input to output data type
  assign i_gain_out = (i_gain[31] != 1'b0) ? 32'b01111111111111111111111111111111 : $signed($signed(i_gain));

// Mux for Saturation logic:
// if input is > upper limit, assign upper limit to output
// else if input is < lower limit, assign lower limit to output
// else assign input to output
// if upper limit is equal to lower limit, assign upper limit to output
// 
  assign GAIN_MAX_MIN_out1 = (i_gain > GAIN_MAX_MIN_upper_limit_int) ? GAIN_MAX_MIN_upper_limit_out :
                            (i_gain < GAIN_MAX_MIN_lower_limit_int) ? GAIN_MAX_MIN_lower_limit_out :
                            i_gain_out;

  always @ (posedge clk or posedge reset)
    begin: Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay1_out1 <= x_nm_i;
        end
      end
    end // Delay1_process


// Saturation block implementation

// Upper Limit (output data type)
  assign POS_MAX_MIN_upper_limit_out = 32'h017D7840;

// Lower Limit (output data type)
  assign POS_MAX_MIN_lower_limit_out = 32'hFE8287C0;

// Mux for Saturation logic:
// if input is > upper limit, assign upper limit to output
// else if input is < lower limit, assign lower limit to output
// else assign input to output
// if upper limit is equal to lower limit, assign upper limit to output
// 
  assign POS_MAX_MIN_out1 = (Delay1_out1 > $signed(POS_MAX_MIN_upper_limit_out)) ? POS_MAX_MIN_upper_limit_out :
                           (Delay1_out1 < $signed(POS_MAX_MIN_lower_limit_out)) ? POS_MAX_MIN_lower_limit_out :
                           Delay1_out1;

  assign mul_temp = POS_MAX_MIN_out1 * factor;
  assign mult0_out1 = mul_temp[31:0];

  assign sub_cast = $signed({{1{mult0_out1[31]}}, mult0_out1});
  assign sub_cast_1 = $signed({{1{dt_Int_1_out1[31]}}, dt_Int_1_out1});
  assign sub_temp = sub_cast - sub_cast_1;
  assign Sum13_out1_tmp = (sub_temp[33] == 1'b0 & sub_temp[32] != 1'b0) ? 33'b011111111111111111111111111111111 : 
      (sub_temp[33] == 1'b1 && sub_temp[32] != 1'b1) ? 33'b100000000000000000000000000000000 : sub_temp[32:0];

  assign Sum13_out1 = (Sum13_out1_tmp[32] == 1'b0 & Sum13_out1_tmp[31] != 1'b0) ? 32'b01111111111111111111111111111111 : 
      (Sum13_out1_tmp[32] == 1'b1 && Sum13_out1_tmp[31] != 1'b1) ? 32'b10000000000000000000000000000000 : Sum13_out1_tmp[31:0];

  assign mul_temp_1 = GAIN_MAX_MIN_out1 * Sum13_out1;
  assign mult1_out1 = mul_temp_1[31:0];

  always @(posedge(reset), posedge(clk))
    begin
      if (reset)
        dt_Int_1_state0 <= dt_Int_1_InitialCondition;
      else 
        if (enb)
          dt_Int_1_state0 <= dt_Int_1_state0_next;

    end

  assign dt_Int_1_out1 = dt_Int_1_state0;
  assign t_2 = dt_Int_1_gainval * mult1_out1;
  assign t_3 = {{10{t_2[63]}}, t_2[63:42]};
  assign dt_Int_1_state0_next = dt_Int_1_state0 + t_3;


  assign x_um_filt_o = dt_Int_1_out1;
  always @ (posedge clk or posedge reset)
    begin: Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay7_out1 <= mult0_out1;
        end
      end
    end // Delay7_process

  assign x_um_o = Delay7_out1;
  always @ (posedge clk or posedge reset)
    begin: Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay2_out1 <= y_nm_i;
        end
      end
    end // Delay2_process


// Saturation block implementation

// Upper Limit (output data type)
  assign POS_MAX_MIN1_upper_limit_out = 32'h017D7840;

// Lower Limit (output data type)
  assign POS_MAX_MIN1_lower_limit_out = 32'hFE8287C0;

// Mux for Saturation logic:
// if input is > upper limit, assign upper limit to output
// else if input is < lower limit, assign lower limit to output
// else assign input to output
// if upper limit is equal to lower limit, assign upper limit to output
// 
  assign POS_MAX_MIN1_out1 = (Delay2_out1 > $signed(POS_MAX_MIN1_upper_limit_out)) ? POS_MAX_MIN1_upper_limit_out :
                            (Delay2_out1 < $signed(POS_MAX_MIN1_lower_limit_out)) ? POS_MAX_MIN1_lower_limit_out :
                            Delay2_out1;

  assign mul_temp_2 = POS_MAX_MIN1_out1 * factor;
  assign mult2_out1 = mul_temp_2[31:0];

  assign sub_cast_2 = $signed({{1{mult2_out1[31]}}, mult2_out1});
  assign sub_cast_3 = $signed({{1{dt_Int_2_out1[31]}}, dt_Int_2_out1});
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign Sum1_out1_tmp = (sub_temp_1[33] == 1'b0 & sub_temp_1[32] != 1'b0) ? 33'b011111111111111111111111111111111 : 
      (sub_temp_1[33] == 1'b1 && sub_temp_1[32] != 1'b1) ? 33'b100000000000000000000000000000000 : sub_temp_1[32:0];

  assign Sum1_out1 = (Sum1_out1_tmp[32] == 1'b0 & Sum1_out1_tmp[31] != 1'b0) ? 32'b01111111111111111111111111111111 : 
      (Sum1_out1_tmp[32] == 1'b1 && Sum1_out1_tmp[31] != 1'b1) ? 32'b10000000000000000000000000000000 : Sum1_out1_tmp[31:0];

  assign mul_temp_3 = GAIN_MAX_MIN_out1 * Sum1_out1;
  assign mult3_out1 = mul_temp_3[31:0];

  always @(posedge(reset), posedge(clk))
    begin
      if (reset)
        dt_Int_2_state0 <= dt_Int_2_InitialCondition;
      else 
        if (enb)
          dt_Int_2_state0 <= dt_Int_2_state0_next;

    end

  assign dt_Int_2_out1 = dt_Int_2_state0;
  assign t_2_1 = dt_Int_2_gainval * mult3_out1;
  assign t_3_1 = {{10{t_2_1[63]}}, t_2_1[63:42]};
  assign dt_Int_2_state0_next = dt_Int_2_state0 + t_3_1;


  assign y_um_filt_o = dt_Int_2_out1;
  always @ (posedge clk or posedge reset)
    begin: Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay6_out1 <= mult2_out1;
        end
      end
    end // Delay6_process

  assign y_um_o = Delay6_out1;
  always @ (posedge clk or posedge reset)
    begin: Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay3_out1 <= Delay1_out1;
        end
      end
    end // Delay3_process

  assign sub_cast_4 = $signed({{1{Delay1_out1[31]}}, Delay1_out1});
  assign sub_cast_5 = $signed({{1{Delay3_out1[31]}}, Delay3_out1});
  assign sub_temp_2 = sub_cast_4 - sub_cast_5;
  assign Sum2_out1_tmp = (sub_temp_2[33] == 1'b0 & sub_temp_2[32] != 1'b0) ? 33'b011111111111111111111111111111111 : 
      (sub_temp_2[33] == 1'b1 && sub_temp_2[32] != 1'b1) ? 33'b100000000000000000000000000000000 : sub_temp_2[32:0];

  assign Sum2_out1 = (Sum2_out1_tmp[32] == 1'b0 & Sum2_out1_tmp[31] != 1'b0) ? 32'b01111111111111111111111111111111 : 
      (Sum2_out1_tmp[32] == 1'b1 && Sum2_out1_tmp[31] != 1'b1) ? 32'b10000000000000000000000000000000 : Sum2_out1_tmp[31:0];

  always @ (posedge clk or posedge reset)
    begin: Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay8_out1 <= Sum2_out1;
        end
      end
    end // Delay8_process

  assign x_dt_nm_o = Delay8_out1;
  always @ (posedge clk or posedge reset)
    begin: Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay5_out1 <= Delay2_out1;
        end
      end
    end // Delay5_process

  assign sub_cast_6 = $signed({{1{Delay2_out1[31]}}, Delay2_out1});
  assign sub_cast_7 = $signed({{1{Delay5_out1[31]}}, Delay5_out1});
  assign sub_temp_3 = sub_cast_6 - sub_cast_7;
  assign Sum5_out1_tmp = (sub_temp_3[33] == 1'b0 & sub_temp_3[32] != 1'b0) ? 33'b011111111111111111111111111111111 : 
      (sub_temp_3[33] == 1'b1 && sub_temp_3[32] != 1'b1) ? 33'b100000000000000000000000000000000 : sub_temp_3[32:0];

  assign Sum5_out1 = (Sum5_out1_tmp[32] == 1'b0 & Sum5_out1_tmp[31] != 1'b0) ? 32'b01111111111111111111111111111111 : 
      (Sum5_out1_tmp[32] == 1'b1 && Sum5_out1_tmp[31] != 1'b1) ? 32'b10000000000000000000000000000000 : Sum5_out1_tmp[31:0];

  always @ (posedge clk or posedge reset)
    begin: Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Delay4_out1 <= Sum5_out1;
        end
      end
    end // Delay4_process

  assign y_dt_nm_o = Delay4_out1;
  assign Logical_Operator_out1 = !trig_in;

  always @ (posedge clk or posedge reset)
    begin: Integer_Delay_process
      if (reset == 1'b1) begin
        Integer_Delay_out1 <= 0;
      end
      else begin
        if (enb == 1'b1) begin
          Integer_Delay_out1 <= Logical_Operator_out1;
        end
      end
    end // Integer_Delay_process

  assign Logical_Operator2_out1 =  trig_in & Integer_Delay_out1;

  assign trig_out = Logical_Operator2_out1;
  always @ (posedge clk or posedge reset)
    begin: cell1_process
      if (reset == 1'b1) begin
        cell1_out1 <= 32'h00000001;
      end
      else begin
        if (enb == 1'b1 & Logical_Operator2_out1 == 1'b1) begin
          cell1_out1 <= Delay4_out1;
        end
      end
    end // cell1_process

  assign y_dt_nm_10hz_o = cell1_out1;
  always @ (posedge clk or posedge reset)
    begin: cell2_process
      if (reset == 1'b1) begin
        cell2_out1 <= 32'h00000001;
      end
      else begin
        if (enb == 1'b1 & Logical_Operator2_out1 == 1'b1) begin
          cell2_out1 <= Delay8_out1;
        end
      end
    end // cell2_process

  assign x_dt_nm_10hz_o = cell2_out1;
  always @ (posedge clk or posedge reset)
    begin: cell3_process
      if (reset == 1'b1) begin
        cell3_out1 <= 32'h00000001;
      end
      else begin
        if (enb == 1'b1 & Logical_Operator2_out1 == 1'b1) begin
          cell3_out1 <= dt_Int_1_out1;
        end
      end
    end // cell3_process

  assign x_um_filt_10hz_o = cell3_out1;
  always @ (posedge clk or posedge reset)
    begin: cell4_process
      if (reset == 1'b1) begin
        cell4_out1 <= 32'h00000001;
      end
      else begin
        if (enb == 1'b1 & Logical_Operator2_out1 == 1'b1) begin
          cell4_out1 <= dt_Int_2_out1;
        end
      end
    end // cell4_process

  assign y_um_filt_10hz_o = cell4_out1;
  assign um_const_out1 = 16'b0111111111111111;

  assign enb = clk_enable;

endmodule  // fa_um_lp_filt

